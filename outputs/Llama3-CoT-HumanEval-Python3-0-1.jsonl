{"task_id": "HumanEval/0", "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n", "entry_point": "has_close_elements", "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n", "sample_io": ["assert has_close_elements([1.0, 2.0, 3.0], 0.5) == False", "assert has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) == True"], "source_codes": ["\ndef encrypt(s):\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            index = d.index(c)\n            rotated_index = (index + 2 * 2) % 26\n            out += d[rotated_index]\n        else:\n            out += c\n    return out\n\n\ndef check_if_last_char_is_a_letter(txt):\n    words = txt.split(' ')\n    last_word = words[-1]\n    is_last_char_letter = len(last_word) == 1 and (97 <= ord(last_word.lower()) <= 122)\n    return is_last_char_letter\n\n\ndef file_name_check(file_name):\n    valid_suffixes = ['txt', 'exe', 'dll']\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    if not parts[1] in valid_suffixes:\n        return 'No'\n    if len(parts[0]) == 0 or not parts[0][0].isalpha():\n        return 'No'\n    num_digits = len([x for x in parts[0] if x.isdigit()])\n    if num_digits > 3:\n        return 'No'\n    return 'Yes'\n\n\ndef fruit_distribution(s, total):\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return total - sum(lis)\n\n\nimport math\n\ndef prime_fib(n: int):\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n\n\ndef has_close_elements(numbers: list[float], threshold: float) -> bool:\n    seen = set()\n    for num in numbers:\n        if num - threshold in seen or any(abs(num - x) < threshold for x in numbers):\n            return True\n        seen.add(num)\n    return False\n\n\n\n"], "responses": ["```python\ndef encrypt(s):\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            index = d.index(c)\n            rotated_index = (index + 2 * 2) % 26\n            out += d[rotated_index]\n        else:\n            out += c\n    return out\n\n\ndef check_if_last_char_is_a_letter(txt):\n    words = txt.split(' ')\n    last_word = words[-1]\n    is_last_char_letter = len(last_word) == 1 and (97 <= ord(last_word.lower()) <= 122)\n    return is_last_char_letter\n\n\ndef file_name_check(file_name):\n    valid_suffixes = ['txt', 'exe', 'dll']\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    if not parts[1] in valid_suffixes:\n        return 'No'\n    if len(parts[0]) == 0 or not parts[0][0].isalpha():\n        return 'No'\n    num_digits = len([x for x in parts[0] if x.isdigit()])\n    if num_digits > 3:\n        return 'No'\n    return 'Yes'\n\n\ndef fruit_distribution(s, total):\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return total - sum(lis)\n\n\nimport math\n\ndef prime_fib(n: int):\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n\n\ndef has_close_elements(numbers: list[float], threshold: float) -> bool:\n    seen = set()\n    for num in numbers:\n        if num - threshold in seen or any(abs(num - x) < threshold for x in numbers):\n            return True\n        seen.add(num)\n    return False\n\n```"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3"}
{"task_id": "HumanEval/1", "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n", "entry_point": "separate_paren_groups", "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n", "sample_io": ["assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']"], "source_codes": ["\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    This function takes a string containing multiple groups of nested parentheses,\n    separates them into individual balanced groups, and returns these groups as a list.\n    \n    Args:\n        paren_string (str): A string containing multiple groups of nested parentheses.\n\n    Returns:\n        List[str]: A list of individual balanced groups of parentheses.\n    \"\"\"\n    # Remove any spaces from the input string\n    paren_string = paren_string.replace(' ', '')\n\n    # Initialize an empty list to store the separate groups\n    result = []\n\n    # Initialize a counter to track the nesting depth\n    depth = 0\n\n    # Initialize an empty string to build the current group\n    curr_group = ''\n\n    # Iterate through each character in the input string\n    for c in paren_string:\n        # If the character is an open parenthesis, increment the nesting depth and add it to the current group\n        if c == '(':\n            depth += 1\n            curr_group += c\n\n        # If the character is a close parenthesis, decrement the nesting depth and add it to the current group\n        elif c == ')':\n            depth -= 1\n            curr_group += c\n\n        # If the character is not a parenthesis or we've reached the end of a balanced group, \n        # append the current group to the result list if it's not empty and reset the current group\n        else:\n            if depth == 0 and curr_group:\n                result.append(curr_group)\n                curr_group = ''\n\n    # If the input string was not empty, check for any leftover characters (e.g., an unbalanced group at the end) \n    # and append them to the result list if present\n    if depth == 0 and curr_group:\n        result.append(curr_group)\n\n    return result\n\n# Test the function with the example input\nprint(separate_paren_groups('( ) (( )) (( )( ))'))  # Output: ['()', '(())', '(()())']\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    This function takes a string containing multiple groups of nested parentheses,\n    separates them into individual balanced groups, and returns these groups as a list.\n    \n    Args:\n        paren_string (str): A string containing multiple groups of nested parentheses.\n\n    Returns:\n        List[str]: A list of individual balanced groups of parentheses.\n    \"\"\"\n    # Remove any spaces from the input string\n    paren_string = paren_string.replace(' ', '')\n\n    # Initialize an empty list to store the separate groups\n    result = []\n\n    # Initialize a counter to track the nesting depth\n    depth = 0\n\n    # Initialize an empty string to build the current group\n    curr_group = ''\n\n    # Iterate through each character in the input string\n    for c in paren_string:\n        # If the character is an open parenthesis, increment the nesting depth and add it to the current group\n        if c == '(':\n            depth += 1\n            curr_group += c\n\n        # If the character is a close parenthesis, decrement the nesting depth and add it to the current group\n        elif c == ')':\n            depth -= 1\n            curr_group += c\n\n        # If the character is not a parenthesis or we've reached the end of a balanced group, \n        # append the current group to the result list if it's not empty and reset the current group\n        else:\n            if depth == 0 and curr_group:\n                result.append(curr_group)\n                curr_group = ''\n\n    # If the input string was not empty, check for any leftover characters (e.g., an unbalanced group at the end) \n    # and append them to the result list if present\n    if depth == 0 and curr_group:\n        result.append(curr_group)\n\n    return result\n\n# Test the function with the example input\nprint(separate_paren_groups('( ) (( )) (( )( ))'))  # Output: ['()', '(())', '(()())']\n```"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3"}
{"task_id": "HumanEval/2", "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n", "entry_point": "truncate_number", "canonical_solution": "    return number % 1.0\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n", "sample_io": ["assert truncate_number(3.5) == 0.5"], "source_codes": ["\ndef encrypt(s):\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            index = d.index(c)\n            rotated_index = (index + 2 * 2) % 26\n            out += d[rotated_index]\n        else:\n            out += c\n    return out\n\ndef check_if_last_char_is_a_letter(txt):\n    words = txt.split(' ')\n    last_word = words[-1]\n    is_last_char_letter = len(last_word) == 1 and (97 <= ord(last_word.lower()) <= 122)\n    return is_last_char_letter\n\ndef file_name_check(file_name):\n    valid_suffixes = ['txt', 'exe', 'dll']\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    if not parts[1] in valid_suffixes:\n        return 'No'\n    if len(parts[0]) == 0 or not parts[0][0].isalpha():\n        return 'No'\n    num_digits = len([x for x in parts[0] if x.isdigit()])\n    if num_digits > 3:\n        return 'No'\n    return 'Yes'\n\ndef fruit_distribution(s, n):\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n\nimport math\n\ndef prime_fib(n: int):\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        \n        if is_prime(f[-1]):\n            n -= 1\n        \n        if n == 0:\n            return f[-1]\n\ndef truncate_number(number: float) -> float:\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\nprint(truncate_number(3.5)) # Output: 0.5\n\n\n"], "responses": ["```python\ndef encrypt(s):\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            index = d.index(c)\n            rotated_index = (index + 2 * 2) % 26\n            out += d[rotated_index]\n        else:\n            out += c\n    return out\n\ndef check_if_last_char_is_a_letter(txt):\n    words = txt.split(' ')\n    last_word = words[-1]\n    is_last_char_letter = len(last_word) == 1 and (97 <= ord(last_word.lower()) <= 122)\n    return is_last_char_letter\n\ndef file_name_check(file_name):\n    valid_suffixes = ['txt', 'exe', 'dll']\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    if not parts[1] in valid_suffixes:\n        return 'No'\n    if len(parts[0]) == 0 or not parts[0][0].isalpha():\n        return 'No'\n    num_digits = len([x for x in parts[0] if x.isdigit()])\n    if num_digits > 3:\n        return 'No'\n    return 'Yes'\n\ndef fruit_distribution(s, n):\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n\nimport math\n\ndef prime_fib(n: int):\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        \n        if is_prime(f[-1]):\n            n -= 1\n        \n        if n == 0:\n            return f[-1]\n\ndef truncate_number(number: float) -> float:\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\nprint(truncate_number(3.5)) # Output: 0.5\n```"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": true, "language": "Python3"}
